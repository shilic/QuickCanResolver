package QuickCanResolver.CanHandle;

/* 为什么选择自定义拷贝接口的方式？
 * 1. 刷新的字段不确定。所以还是得通过之前绑定到信号上的字段确定哪些字段需要刷新数据。所以得反射和拷贝相结合才能正确刷新字段信息。
 * 2. 刷新的数据模型不确定。为了保证程序的适配性，确保所有的数据模型都能正确适配，故该接口只能返回 Object 或者 泛型。
 * 3. clone 方法的实现通常在 Object 类中声明为 protected。因为类型不确定，故我们无法直接使用 clone 方法，故只有通过自定义 克隆接口 。
 *  */
/**
 * 自定义的 copy 接口，用于拷贝数据模型。 <br>
 * 自定义数据模型需要实现该接口，否则无法生成新对象。 <br>
 */
public interface CanCopyable<T> {
    /**
     * 自定义的 copy 接口，用于拷贝数据模型，请返回拷贝之后的数据模型。
     * @return 返回拷贝之后的数据模型
     */
    T copyNew();
}
